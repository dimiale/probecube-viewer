<script>
    // ========== CONFIGURATION - UPDATE THESE VALUES ==========
    const GITHUB_USERNAME = 'dimiale';
    const GITHUB_REPO = 'probecube-viewer';
    const FOLDER_PATH = '211102_models';
    // =========================================================
    
    const TOTAL_MODELS = 39;
    
    // Generate state values and filenames
    const states = [];
    const filenames = [];
    for (let i = 5; i <= 195; i += 5) {
        states.push((i / 100).toFixed(2));
        const stateStr = String(i).padStart(4, '0');
        filenames.push(`glb_state_${stateStr}.glb`);
    }
    
    // Build base URL
    const BASE_URL = `https://raw.githubusercontent.com/${GITHUB_USERNAME}/${GITHUB_REPO}/main/${FOLDER_PATH}/`;
    
    // Scene setup
    const scene = new THREE.Scene();
    
    // Camera with adjusted near/far planes to prevent clipping
    const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.01,
        10000
    );
    camera.position.set(3, 3, 3);
    
    const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('canvas'),
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0);
    renderer.shadowMap.enabled = true;
    
    // Simple, strong lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);
    
    const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
    light1.position.set(10, 10, 10);
    scene.add(light1);
    
    const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
    light2.position.set(-10, 10, -10);
    scene.add(light2);
    
    const light3 = new THREE.DirectionalLight(0xffffff, 0.3);
    light3.position.set(0, -10, 0);
    scene.add(light3);
    
    // OrbitControls with adjusted settings
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.minDistance = 0.1;
    controls.maxDistance = 100;
    controls.autoRotate = false;
    controls.enableZoom = false;
    
    // Mobile touch controls - 2 fingers only
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
               || window.innerWidth <= 768;
    }
    
    if (isMobileDevice()) {
        // Disable default OrbitControls touch behavior
        controls.enableRotate = false;
        controls.enableZoom = false;
        controls.enablePan = false;
        
        // Custom two-finger touch handling
        let touchStartDistance = 0;
        let touchStartPositions = [];
        let isTwoFingerTouch = false;
        let lastTouchY = 0;
        
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                isTwoFingerTouch = true;
                
                // Store initial touch positions
                touchStartPositions = [
                    { x: e.touches[0].clientX, y: e.touches[0].clientY },
                    { x: e.touches[1].clientX, y: e.touches[1].clientY }
                ];
                
                // Calculate initial distance for pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            } else if (e.touches.length === 1) {
                // Single finger - send scroll message to parent
                isTwoFingerTouch = false;
                lastTouchY = e.touches[0].clientY;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && isTwoFingerTouch) {
                e.preventDefault();
                
                // PINCH ZOOM
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                
                if (touchStartDistance > 0) {
                    const zoomDelta = currentDistance / touchStartDistance;
                    const zoomSpeed = 0.3;
                    const scaleFactor = 1 + (1 - zoomDelta) * zoomSpeed;
                    
                    camera.position.sub(controls.target).multiplyScalar(scaleFactor).add(controls.target);
                }
                touchStartDistance = currentDistance;
                
                // TWO-FINGER ROTATION
                const currentPositions = [
                    { x: e.touches[0].clientX, y: e.touches[0].clientY },
                    { x: e.touches[1].clientX, y: e.touches[1].clientY }
                ];
                
                const avgDeltaX = ((currentPositions[0].x - touchStartPositions[0].x) + 
                                  (currentPositions[1].x - touchStartPositions[1].x)) / 2;
                const avgDeltaY = ((currentPositions[0].y - touchStartPositions[0].y) + 
                                  (currentPositions[1].y - touchStartPositions[1].y)) / 2;
                
                const rotationSpeed = 0.005;
                
                const deltaAzimuth = avgDeltaX * rotationSpeed;
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position.clone().sub(controls.target));
                spherical.theta -= deltaAzimuth;
                
                const deltaPolar = avgDeltaY * rotationSpeed;
                spherical.phi -= deltaPolar;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical).add(controls.target);
                camera.lookAt(controls.target);
                
                touchStartPositions = currentPositions;
                controls.update();
            } else if (e.touches.length === 1 && !isTwoFingerTouch) {
                // Single finger movement - calculate scroll delta and send to parent
                const currentY = e.touches[0].clientY;
                const deltaY = lastTouchY - currentY;
                lastTouchY = currentY;
                
                // Send scroll message to parent Wix page
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'scroll',
                        deltaY: deltaY
                    }, '*');
                }
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                isTwoFingerTouch = false;
                touchStartDistance = 0;
            }
        }, { passive: false });
        
    } else {
        // PC - keep panning disabled but rotation/zoom enabled
        controls.enablePan = false;
    }
    
    // Manual zoom with Shift key requirement (PC only)
    renderer.domElement.addEventListener('wheel', (e) => {
        if (e.shiftKey) {
            e.preventDefault();
            e.stopPropagation();
            
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            
            camera.position.sub(controls.target).multiplyScalar(delta).add(controls.target);
            controls.update();
        }
    }, { passive: false });
    
    // Model storage
    const models = [];
    let currentModelIndex = 0;
    
    // UI elements
    const slider = document.getElementById('slider');
    const loading = document.getElementById('loading');
    const controlsUI = document.getElementById('controls');
    const progressBar = document.getElementById('progress-bar');
    
    // Load models
    const loader = new THREE.GLTFLoader();
    let loadedCount = 0;
    
    function updateProgress() {
        const percent = (loadedCount / TOTAL_MODELS) * 100;
        progressBar.style.width = percent + '%';
    }
    
    function fitCameraToModel(model) {
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        
        const maxSize = Math.max(size.x, size.y, size.z);
        const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
        const fitWidthDistance = fitHeightDistance / camera.aspect;
        const distance = Math.max(fitHeightDistance, fitWidthDistance) * 0.9;
        
        const direction = new THREE.Vector3(1, 1, 1).normalize();
        camera.position.copy(center).add(direction.multiplyScalar(distance));
        
        const shiftAmount = maxSize * 0.2;
        camera.position.y -= shiftAmount;
        const adjustedCenter = center.clone();
        adjustedCenter.y -= shiftAmount;
        
        camera.lookAt(adjustedCenter);
        controls.target.copy(adjustedCenter);
        controls.update();
    }
    
    function loadModel(index) {
        return new Promise((resolve, reject) => {
            const filename = filenames[index];
            const url = BASE_URL + filename;
            
            loader.load(
                url,
                (gltf) => {
                    const model = gltf.scene;
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            if (!child.material || child.material.color.r === 0 && child.material.color.g === 0 && child.material.color.b === 0) {
                                child.material = new THREE.MeshStandardMaterial({
                                    color: 0xaaaaaa,
                                    metalness: 0.2,
                                    roughness: 0.7,
                                    side: THREE.DoubleSide
                                });
                            }
                        }
                    });
                    
                    model.visible = (index === 0);
                    scene.add(model);
                    models.push(model);
                    
                    if (index === 0) {
                        fitCameraToModel(model);
                    }
                    
                    loadedCount++;
                    updateProgress();
                    resolve();
                },
                undefined,
                (error) => {
                    console.error('Error loading model:', filename, error);
                    loadedCount++;
                    updateProgress();
                    resolve();
                }
            );
        });
    }
    
    async function loadAllModels() {
        try {
            for (let i = 0; i < TOTAL_MODELS; i++) {
                await loadModel(i);
            }
            loading.classList.add('hidden');
            controlsUI.classList.remove('hidden');
        } catch (error) {
            console.error('Error loading models:', error);
        }
    }
    
    slider.addEventListener('input', (e) => {
        const newIndex = parseInt(e.target.value);
        
        if (models[currentModelIndex]) {
            models[currentModelIndex].visible = false;
        }
        
        if (models[newIndex]) {
            models[newIndex].visible = true;
        }
        
        currentModelIndex = newIndex;
    });
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    loadAllModels();
    animate();
</script>
